

// main.js
const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const path = require('path');
const fs = require('fs');
const { autoUpdater } = require('electron-updater');
const { exec } = require('child_process');
const { shell } = require('electron');
const { version } = require('./package.json');


// Configure logging for autoUpdater
autoUpdater.logger = require('electron-log');
autoUpdater.logger.transports.file.level = 'info';

const fileWatchers = new Map();

function getFilenameWithoutExt(filePath) {
    return path.basename(filePath, path.extname(filePath));
}

function createWindow() {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 1280,
    height: 800,
    webPreferences: {
      contextIsolation: false,
      nodeIntegration: true,
    },
    icon: path.join(__dirname, 'assets/icon.png')
  });

  // Load the index.html file from the 'dist' folder generated by Vite.
  mainWindow.loadFile(path.join(__dirname, 'dist', 'index.html'));

  // Optional: Uncomment the line below to open developer tools on startup.
  // mainWindow.webContents.openDevTools();
}

app.whenReady().then(() => {
  createWindow();

  autoUpdater.checkForUpdatesAndNotify();

  ipcMain.handle('get-app-version', () => {
    return version;
  });

  ipcMain.handle('save-file-dialog', async (event, { defaultPath, fileContent }) => {
    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) {
        return { success: false, error: 'Không tìm thấy cửa sổ ứng dụng.' };
    }
    const result = await dialog.showSaveDialog(mainWindow, {
        title: 'Lưu Kịch Bản Prompt',
        defaultPath: defaultPath,
        filters: [{ name: 'Excel Workbook', extensions: ['xlsx'] }]
    });
    if (result.canceled || !result.filePath) {
        return { success: false, error: 'Save dialog canceled' };
    }
    try {
        fs.writeFileSync(result.filePath, Buffer.from(fileContent));
        return { success: true, filePath: result.filePath };
    } catch (err) {
        console.error('Failed to save file:', err);
        return { success: false, error: err.message };
    }
  });

  ipcMain.handle('open-file-dialog', async (event) => {
    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) return { success: false, error: 'Window not found.' };
    const result = await dialog.showOpenDialog(mainWindow, {
        properties: ['openFile'],
        filters: [{ name: 'Excel Files', extensions: ['xlsx', 'xls'] }]
    });
    if (result.canceled || result.filePaths.length === 0) {
        return { success: false };
    }
    const filePath = result.filePaths[0];
    try {
        const content = fs.readFileSync(filePath);
        return { success: true, path: filePath, content: content, name: path.basename(filePath) };
    } catch (err) {
        return { success: false, error: err.message };
    }
  });

  ipcMain.on('start-watching-file', (event, filePath) => {
    if (!filePath || fileWatchers.has(filePath)) {
        return;
    }
    try {
        const watcher = fs.watch(filePath, (eventType) => {
            if (eventType === 'change') {
                try {
                    const content = fs.readFileSync(filePath);
                    const mainWindow = BrowserWindow.fromWebContents(event.sender);
                    mainWindow?.webContents.send('file-content-updated', { path: filePath, content });
                } catch (readErr) {
                    console.error(`Error reading watched file ${filePath}:`, readErr);
                    // Inform renderer that the file might be gone
                }
            }
        });

        watcher.on('error', (err) => {
            console.error(`Watcher error for ${filePath}:`, err);
            ipcMain.emit('stop-watching-file', event, filePath);
        });

        fileWatchers.set(filePath, watcher);
        console.log(`Started watching ${filePath}`);
    } catch (watchErr) {
        console.error(`Failed to start watching ${filePath}:`, watchErr);
    }
  });

  ipcMain.on('stop-watching-file', (event, filePath) => {
    if (fileWatchers.has(filePath)) {
        fileWatchers.get(filePath).close();
        fileWatchers.delete(filePath);
        console.log(`Stopped watching ${filePath}`);
    }
  });

  // --- New IPC Handlers ---
  ipcMain.on('launch-video-tool', (event, filePath) => {
    if (!filePath) {
        dialog.showErrorBox('Lỗi', 'Đường dẫn đến ToolsFlow chưa được cấu hình.');
        return;
    }
    // IMPORTANT: Wrap the file path in quotes to handle paths with spaces
    const command = `"${filePath}"`;
    exec(command, (error) => {
        if (error) {
            console.error(`exec error: ${error}`);
            dialog.showErrorBox('Lỗi', `Không thể khởi động ứng dụng tại đường dẫn:\n${filePath}\n\nVui lòng kiểm tra lại đường dẫn và thử lại.\n\nChi tiết: ${error.message}`);
        }
    });
  });

  ipcMain.handle('select-toolsflow-path', async (event) => {
    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) return null;

    const result = await dialog.showOpenDialog(mainWindow, {
        title: 'Chọn file thực thi ToolsFlow',
        properties: ['openFile'],
        filters: [
            { name: 'Executable', extensions: ['exe'] },
            { name: 'All Files', extensions: ['*'] }
        ]
    });

    if (result.canceled || result.filePaths.length === 0) {
        return null;
    }
    return result.filePaths[0];
  });

  ipcMain.on('open-file-location', (event, filePath) => {
      if (filePath) {
          shell.showItemInFolder(filePath);
      }
  });

  ipcMain.handle('check-file-exists', (event, filePath) => {
      if (!filePath) return false;
      return fs.existsSync(filePath);
  });
  
  ipcMain.handle('get-directory-path', (event, filePath) => {
      if (!filePath) return null;
      return path.dirname(filePath);
  });

  ipcMain.handle('path-join', (event, ...args) => {
      return path.join(...args);
  });

  ipcMain.handle('find-video-file', async (event, { excelPath, videoFileName }) => {
    if (!excelPath || !videoFileName) return null;
    
    const baseDir = path.dirname(excelPath);
    const excelFilenameWithoutExt = getFilenameWithoutExt(excelPath);

    // Path 1: Same directory as the excel file
    const path1 = path.join(baseDir, videoFileName);
    if (fs.existsSync(path1)) {
        return path1;
    }

    // Path 2: Subdirectory with the same name as the excel file
    const path2 = path.join(baseDir, excelFilenameWithoutExt, videoFileName);
    if (fs.existsSync(path2)) {
        return path2;
    }

    return null; // Not found
  });

  ipcMain.handle('delete-video-file', async (event, filePath) => {
    try {
        await shell.trashItem(filePath);
        return { success: true };
    } catch (error) {
        console.error(`Failed to trash item ${filePath}:`, error);
        return { success: false, error: error.message };
    }
  });

  ipcMain.handle('open-video-file', async(event, filePath) => {
    try {
        const errorMessage = await shell.openPath(filePath);
        if (errorMessage) {
            return { success: false, error: errorMessage };
        }
        return { success: true };
    } catch (error) {
        console.error(`Failed to open item ${filePath}:`, error);
        return { success: false, error: error.message };
    }
  });


});

autoUpdater.on('checking-for-update', () => console.log('Checking for update...'));
autoUpdater.on('update-available', (info) => console.log('Update available.', info));
autoUpdater.on('update-not-available', (info) => console.log('Update not available.', info));
autoUpdater.on('error', (err) => console.error('Error in auto-updater. ' + err));
autoUpdater.on('update-downloaded', (info) => console.log('Update downloaded.', info));

app.on('window-all-closed', () => {
  fileWatchers.forEach(watcher => watcher.close());
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
// main.js
const { app, BrowserWindow, ipcMain, dialog, shell } = require('electron');
const path = require('path');
const fs = require('fs');
const { autoUpdater } = require('electron-updater');
const { exec, execFile } = require('child_process');
const https = require('https');

// Configure logging for autoUpdater
autoUpdater.logger = require('electron-log');
autoUpdater.logger.transports.file.level = 'info';

const fileWatchers = new Map();
const userDataPath = app.getPath('userData');
const configPath = path.join(userDataPath, 'app-config.json');

// --- Helper functions for config ---
function readConfig() {
  try {
    if (fs.existsSync(configPath)) {
      return JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    }
  } catch (error) {
    console.error('Error reading config file:', error);
  }
  return {}; // Return empty object if file doesn't exist or is corrupted
}

function writeConfig(config) {
  try {
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
  } catch (error) {
    console.error('Error writing config file:', error);
  }
}

// Helper function to find files recursively
async function findFilesRecursively(dir) {
    if (!fs.existsSync(dir)) return [];
    const dirents = await fs.promises.readdir(dir, { withFileTypes: true });
    const files = await Promise.all(dirents.map((dirent) => {
        const res = path.resolve(dir, dirent.name);
        return dirent.isDirectory() ? findFilesRecursively(res) : res;
    }));
    return Array.prototype.concat(...files);
}


function createWindow() {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 1280,
    height: 800,
    webPreferences: {
      contextIsolation: false,
      nodeIntegration: true,
    },
    icon: path.join(__dirname, 'assets/icon.png')
  });

  // Load the index.html file from the 'dist' folder generated by Vite.
  mainWindow.loadFile(path.join(__dirname, 'dist', 'index.html'));

  // Optional: Uncomment the line below to open developer tools on startup.
  // mainWindow.webContents.openDevTools();
}

app.whenReady().then(() => {
  createWindow();

  autoUpdater.checkForUpdatesAndNotify();

  ipcMain.handle('get-app-version', () => {
    return app.getVersion();
  });

  ipcMain.handle('save-file-dialog', async (event, { defaultPath, fileContent }) => {
    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) {
        return { success: false, error: 'Không tìm thấy cửa sổ ứng dụng.' };
    }
    const result = await dialog.showSaveDialog(mainWindow, {
        title: 'Lưu Kịch Bản Prompt',
        defaultPath: defaultPath,
        filters: [{ name: 'Excel Workbook', extensions: ['xlsx'] }]
    });
    if (result.canceled || !result.filePath) {
        return { success: false, error: 'Save dialog canceled' };
    }
    try {
        fs.writeFileSync(result.filePath, Buffer.from(fileContent));
        return { success: true, filePath: result.filePath };
    } catch (err) {
        console.error('Failed to save file:', err);
        return { success: false, error: err.message };
    }
  });

  ipcMain.handle('open-file-dialog', async (event) => {
    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) return { success: false, error: 'Window not found.' };
    const result = await dialog.showOpenDialog(mainWindow, {
        properties: ['openFile'],
        filters: [{ name: 'Excel Files', extensions: ['xlsx', 'xls'] }]
    });
    if (result.canceled || result.filePaths.length === 0) {
        return { success: false };
    }
    const filePath = result.filePaths[0];
    try {
        const content = fs.readFileSync(filePath);
        return { success: true, path: filePath, content: content, name: path.basename(filePath) };
    } catch (err) {
        return { success: false, error: err.message };
    }
  });
  
  ipcMain.handle('open-video-file-dialog', async (event) => {
    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) return { success: false, error: 'Window not found.' };
    const result = await dialog.showOpenDialog(mainWindow, {
        properties: ['openFile'],
        filters: [{ name: 'Video Files', extensions: ['mp4', 'mov', 'avi', 'mkv', 'webm'] }]
    });
    if (result.canceled || result.filePaths.length === 0) {
        return { success: false };
    }
    const filePath = result.filePaths[0];
    return { success: true, path: filePath };
  });

  ipcMain.on('start-watching-file', (event, filePath) => {
    if (!filePath || fileWatchers.has(filePath)) {
        return;
    }
    try {
        const watcher = fs.watch(filePath, (eventType) => {
            if (eventType === 'change') {
                try {
                    const content = fs.readFileSync(filePath);
                    const mainWindow = BrowserWindow.fromWebContents(event.sender);
                    mainWindow?.webContents.send('file-content-updated', { path: filePath, content });
                } catch (readErr) {
                    console.error(`Error reading watched file ${filePath}:`, readErr);
                }
            }
        });

        watcher.on('error', (err) => {
            console.error(`Watcher error for ${filePath}:`, err);
            ipcMain.emit('stop-watching-file', event, filePath);
        });

        fileWatchers.set(filePath, watcher);
        console.log(`Started watching ${filePath}`);
    } catch (watchErr) {
        console.error(`Failed to start watching ${filePath}:`, watchErr);
    }
  });

  ipcMain.on('stop-watching-file', (event, filePath) => {
    if (fileWatchers.has(filePath)) {
        fileWatchers.get(filePath).close();
        fileWatchers.delete(filePath);
        console.log(`Stopped watching ${filePath}`);
    }
  });

  ipcMain.on('open-folder', (event, folderPath) => {
    if (folderPath) {
        shell.openPath(folderPath).catch(err => console.error("Failed to open path", err));
    }
  });

  ipcMain.handle('open-tool-flow', async (event) => {
    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) return { success: false, error: 'Window not found.' };

    let config = readConfig();
    let toolFlowPath = config.toolFlowPath;

    if (!toolFlowPath || !fs.existsSync(toolFlowPath)) {
        const result = await dialog.showOpenDialog(mainWindow, {
            title: 'Chọn ứng dụng ToolFlows',
            properties: ['openFile'],
            filters: process.platform === 'win32'
                ? [{ name: 'Applications', extensions: ['exe'] }]
                : [{ name: 'Applications', extensions: ['app', '*'] }]
        });

        if (result.canceled || result.filePaths.length === 0) {
            return { success: false, error: 'User canceled selection.' };
        }

        toolFlowPath = result.filePaths[0];
        config.toolFlowPath = toolFlowPath;
        writeConfig(config);
    }
    
    try {
        const err = await shell.openPath(toolFlowPath);
        if (err) {
            console.error('Failed to open ToolFlows:', err);
            let config = readConfig();
            delete config.toolFlowPath;
            writeConfig(config);
            return { success: false, error: `Không thể mở ứng dụng. Vui lòng chọn lại. Lỗi: ${err}` };
        }
        return { success: true };
    } catch (e) {
        console.error('Exception opening ToolFlows:', e);
        return { success: false, error: 'Đã xảy ra lỗi không mong muốn khi cố gắng mở ứng dụng.' };
    }
  });

    // --- Video Management ---
    ipcMain.handle('find-videos-for-jobs', async (event, { jobs, basePath }) => {
        if (!basePath || !fs.existsSync(basePath)) {
            return { success: false, jobs: jobs, error: "Base path does not exist." };
        }
    
        try {
            const allFiles = await findFilesRecursively(basePath);
            const videoFiles = allFiles.filter(file => /\.(mp4|mov|avi|mkv|webm)$/i.test(file));
            
            const updatedJobs = jobs.map(job => {
                if (job.status === 'Completed' && !job.videoPath) {
                    const videoNamePattern = `Video_${job.id}_${job.videoName}`;
                    const foundVideo = videoFiles.find(file => {
                        const fileNameWithoutExt = path.parse(file).name;
                        return fileNameWithoutExt === videoNamePattern;
                    });
    
                    if (foundVideo) {
                        return { ...job, videoPath: foundVideo };
                    }
                }
                return job;
            });
    
            return { success: true, jobs: updatedJobs };
        } catch (err) {
            console.error("Error finding videos:", err);
            return { success: false, jobs: jobs, error: err.message };
        }
    });
    
    ipcMain.on('open-video-path', (event, videoPath) => {
        if (videoPath && fs.existsSync(videoPath)) {
            shell.openPath(videoPath).catch(err => console.error(`Failed to open video: ${videoPath}`, err));
        }
    });
    
    ipcMain.on('show-video-in-folder', (event, videoPath) => {
        if (videoPath && fs.existsSync(videoPath)) {
            shell.showItemInFolder(videoPath);
        }
    });
    
    ipcMain.handle('delete-video-file', async (event, videoPath) => {
        if (!videoPath || !fs.existsSync(videoPath)) {
            return { success: false, error: 'File not found.' };
        }
        const mainWindow = BrowserWindow.getFocusedWindow();
        const result = await dialog.showMessageBox(mainWindow, {
            type: 'warning',
            buttons: ['Hủy', 'Xóa'],
            defaultId: 0,
            title: 'Xác nhận xóa',
            message: 'Bạn có chắc chắn muốn xóa video này không?',
            detail: `Video sẽ được chuyển vào thùng rác.\n${videoPath}`
        });
    
        if (result.response === 1) { // 'Xóa' button
            try {
                await shell.trashItem(videoPath);
                return { success: true };
            } catch (error) {
                console.error('Failed to delete video:', error);
                return { success: false, error: error.message };
            }
        } else {
            return { success: false, error: 'User canceled deletion.' };
        }
    });

    // --- FFmpeg Management ---
    const ffmpegDir = path.join(app.getPath('userData'), 'ffmpeg_bin');
    const ffmpegExe = process.platform === 'win32' ? 'ffmpeg.exe' : 'ffmpeg';
    const ffprobeExe = process.platform === 'win32' ? 'ffprobe.exe' : 'ffprobe';
    const ffmpegPath = path.join(ffmpegDir, ffmpegExe);
    const ffprobePath = path.join(ffmpegDir, ffprobeExe);
    
    ipcMain.handle('check-ffmpeg', async () => {
        // Strict check: both ffmpeg and ffprobe must exist in our managed directory.
        if (fs.existsSync(ffmpegPath) && fs.existsSync(ffprobePath)) {
            return { found: true, path: ffmpegPath };
        }
        // We no longer check for a system-wide ffmpeg to ensure consistency and reliability,
        // as the app now manages its own installation.
        return { found: false };
    });

    ipcMain.handle('install-ffmpeg', (event) => {
        return new Promise(async (resolve, reject) => {
            const mainWindow = BrowserWindow.fromWebContents(event.sender);
            const platform = process.platform;
            let downloadUrl;
            
            if (platform === 'win32') {
                downloadUrl = 'https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip';
            } else if (platform === 'darwin') {
                downloadUrl = `https://evermeet.cx/ffmpeg/ffmpeg-7.0.zip`;
            } else {
                return resolve({ success: false, error: 'Hệ điều hành không được hỗ trợ để cài đặt tự động.' });
            }

            if (!fs.existsSync(ffmpegDir)) {
                fs.mkdirSync(ffmpegDir, { recursive: true });
            }
            const zipPath = path.join(ffmpegDir, 'ffmpeg.zip');

            const file = fs.createWriteStream(zipPath);
            https.get(downloadUrl, (response) => {
                if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
                    // Handle redirect
                    https.get(response.headers.location, (redirectResponse) => {
                        redirectResponse.pipe(file);
                        file.on('finish', () => {
                            file.close();
                            extractAndInstall();
                        });
                    }).on('error', (err) => {
                        fs.unlink(zipPath, () => {});
                        resolve({ success: false, error: `Lỗi tải file (redirect): ${err.message}` });
                    });
                    return;
                }
                
                response.pipe(file);
                file.on('finish', () => {
                    file.close();
                    extractAndInstall();
                });
            }).on('error', (err) => {
                fs.unlink(zipPath, () => {});
                resolve({ success: false, error: `Lỗi tải file: ${err.message}` });
            });

            const extractAndInstall = () => {
                const extractDir = path.join(ffmpegDir, 'extracted');
                if (fs.existsSync(extractDir)) fs.rmSync(extractDir, { recursive: true, force: true });
                fs.mkdirSync(extractDir);

                const callback = async (error) => {
                    if (error) {
                        return resolve({ success: false, error: `Lỗi giải nén: ${error.message}` });
                    }
                    
                    try {
                        const allFiles = await findFilesRecursively(extractDir);
                        
                        const ffmpegBinaryName = platform === 'win32' ? 'ffmpeg.exe' : 'ffmpeg';
                        const ffmpegBinary = allFiles.find(f => path.basename(f) === ffmpegBinaryName);
                        if (!ffmpegBinary) {
                           return resolve({ success: false, error: 'Không tìm thấy file thực thi ffmpeg sau khi giải nén.' });
                        }
                        fs.copyFileSync(ffmpegBinary, ffmpegPath);
                        fs.chmodSync(ffmpegPath, 0o755);

                        const ffprobeBinaryName = platform === 'win32' ? 'ffprobe.exe' : 'ffprobe';
                        const ffprobeBinary = allFiles.find(f => path.basename(f) === ffprobeBinaryName);
                        const ffprobeDestPath = path.join(ffmpegDir, ffprobeBinaryName);
                        if (!ffprobeBinary) {
                           return resolve({ success: false, error: 'Không tìm thấy file thực thi ffprobe sau khi giải nén.' });
                        }
                        fs.copyFileSync(ffprobeBinary, ffprobeDestPath);
                        fs.chmodSync(ffprobeDestPath, 0o755);

                        fs.unlinkSync(zipPath);
                        fs.rmSync(extractDir, { recursive: true, force: true });

                        resolve({ success: true, path: ffmpegPath });
                    } catch (e) {
                        resolve({ success: false, error: `Lỗi cài đặt: ${e.message}` });
                    }
                };

                if (platform === 'win32') {
                    execFile('powershell', ['-command', 'Expand-Archive', '-Path', zipPath, '-DestinationPath', extractDir, '-Force'], callback);
                } else { // darwin
                    execFile('unzip', ['-o', zipPath, '-d', extractDir], callback);
                }
            };
        });
    });

    ipcMain.handle('execute-ffmpeg-combine', async (event, { ffmpegPath, jobs, targetDuration, mode }) => {
        const mainWindow = BrowserWindow.getFocusedWindow();
        if (!mainWindow) return { success: false, error: 'Window not found.' };

        const defaultFileName = `combined_${Date.now()}.mp4`;
        const saveDialogResult = await dialog.showSaveDialog(mainWindow, {
            title: 'Lưu Video Đã Ghép',
            defaultPath: defaultFileName,
            filters: [{ name: 'MP4 Video', extensions: ['mp4'] }]
        });

        if (saveDialogResult.canceled || !saveDialogResult.filePath) {
            return { success: false, error: 'Save dialog canceled' };
        }
        const outputFilePath = saveDialogResult.filePath;
        
        const inputArgs = jobs.flatMap(job => ['-i', job.videoPath]);
        
        let commandArgs;

        if (mode === 'timed') {
            try {
                const ffprobePath = path.join(path.dirname(ffmpegPath), process.platform === 'win32' ? 'ffprobe.exe' : 'ffprobe');
                
                const getDurationPromises = jobs.map(job => 
                    new Promise((resolve, reject) => {
                        const args = ['-v', 'error', '-show_entries', 'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', job.videoPath];
                        execFile(ffprobePath, args, (err, stdout, stderr) => {
                            if (err) {
                                reject(new Error(`ffprobe error for ${job.videoName}: ${err.message}`));
                                return;
                            }
                            resolve(parseFloat(stdout));
                        });
                    })
                );
                
                const durations = await Promise.all(getDurationPromises);
                const actualTotalDuration = durations.reduce((sum, duration) => sum + duration, 0);

                if (actualTotalDuration <= 0) {
                    return { success: false, error: 'Không thể xác định tổng thời lượng của các video nguồn.' };
                }
                
                const speedFactor = actualTotalDuration / targetDuration;
                if (speedFactor <= 0) {
                     return { success: false, error: 'Hệ số tốc độ không hợp lệ. Vui lòng kiểm tra lại thời lượng.' };
                }
                const ptsMultiplier = (1 / speedFactor).toFixed(6);
                
                const filterParts = jobs.map((_, index) => `[${index}:v]setpts=${ptsMultiplier}*PTS[v${index}]`);
                const concatVideoInputs = jobs.map((_, index) => `[v${index}]`).join('');
                const filterComplex = `${filterParts.join(';')};${concatVideoInputs}concat=n=${jobs.length}:v=1:a=0[v]`;
                commandArgs = [...inputArgs, '-filter_complex', filterComplex, '-map', '[v]', '-y', outputFilePath];

            } catch (err) {
                 return { success: false, error: `Lỗi khi lấy thời lượng video: ${err.message}` };
            }
        } else { // 'normal' mode
            const concatInputs = jobs.map((_, index) => `[${index}:v]`).join('');
            const filterComplex = `${concatInputs}concat=n=${jobs.length}:v=1:a=0[v]`;
            commandArgs = [...inputArgs, '-filter_complex', filterComplex, '-map', '[v]', '-y', outputFilePath];
        }

        return new Promise((resolve) => {
            execFile(ffmpegPath, commandArgs, (error, stdout, stderr) => {
                if (error) {
                    console.error(`ffmpeg execFile error: ${error}`);
                    resolve({ success: false, error: `Lỗi FFmpeg: ${error.message}` });
                    return;
                }
                resolve({ success: true, filePath: outputFilePath });
            });
        });
    });

});

autoUpdater.on('checking-for-update', () => console.log('Checking for update...'));
autoUpdater.on('update-available', (info) => console.log('Update available.', info));
autoUpdater.on('update-not-available', (info) => console.log('Update not available.', info));
autoUpdater.on('error', (err) => console.error('Error in auto-updater. ' + err));
autoUpdater.on('update-downloaded', (info) => console.log('Update downloaded.', info));

app.on('window-all-closed', () => {
  fileWatchers.forEach(watcher => watcher.close());
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});